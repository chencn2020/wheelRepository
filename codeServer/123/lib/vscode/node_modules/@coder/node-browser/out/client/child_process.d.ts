/// <reference types="node" />
import * as cp from "child_process";
import * as net from "net";
import * as stream from "stream";
import { ClientProxy, ClientServerProxy } from "../common/proxy";
import { ChildProcessModuleProxy, ChildProcessProxy } from "../server/child_process";
import { ClientReadableProxy, ClientWritableProxy } from "./stream";
export interface ClientChildProcessProxy extends ChildProcessProxy, ClientServerProxy<cp.ChildProcess> {
}
export interface ClientChildProcessProxies {
    childProcess: ClientChildProcessProxy;
    stdin?: ClientWritableProxy | null;
    stdout?: ClientReadableProxy | null;
    stderr?: ClientReadableProxy | null;
}
export declare class ChildProcess extends ClientProxy<ClientChildProcessProxy> implements cp.ChildProcess {
    readonly stdin: stream.Writable;
    readonly stdout: stream.Readable;
    readonly stderr: stream.Readable;
    readonly stdio: [stream.Writable, stream.Readable, stream.Readable];
    private _connected;
    private _killed;
    private _pid;
    constructor(proxyPromises: Promise<ClientChildProcessProxies>);
    readonly pid: number;
    readonly connected: boolean;
    readonly killed: boolean;
    kill(): void;
    disconnect(): void;
    ref(): void;
    unref(): void;
    send(message: any, sendHandle?: net.Socket | net.Server | ((error: Error) => void), options?: cp.MessageOptions | ((error: Error) => void), callback?: (error: Error) => void): boolean;
    /**
     * Exit and close the process when disconnected.
     */
    protected handleDisconnect(): void;
}
interface ClientChildProcessModuleProxy extends ChildProcessModuleProxy, ClientServerProxy {
    exec(command: string, options?: {
        encoding?: string | null;
    } & cp.ExecOptions | null, callback?: (error: cp.ExecException | null, stdin: string | Buffer, stdout: string | Buffer) => void): Promise<ClientChildProcessProxies>;
    fork(modulePath: string, args?: string[], options?: cp.ForkOptions): Promise<ClientChildProcessProxies>;
    spawn(command: string, args?: string[], options?: cp.SpawnOptions): Promise<ClientChildProcessProxies>;
}
export declare class ChildProcessModule {
    private readonly proxy;
    constructor(proxy: ClientChildProcessModuleProxy);
    exec: (command: string, options?: ({
        encoding?: string | null | undefined;
    } & cp.ExecOptions) | ((error: cp.ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void) | null | undefined, callback?: ((error: cp.ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined) => cp.ChildProcess;
    fork: (modulePath: string, args?: string[] | cp.ForkOptions | undefined, options?: cp.ForkOptions | undefined) => cp.ChildProcess;
    spawn: (command: string, args?: string[] | cp.SpawnOptions | undefined, options?: cp.SpawnOptions | undefined) => cp.ChildProcess;
}
export {};
