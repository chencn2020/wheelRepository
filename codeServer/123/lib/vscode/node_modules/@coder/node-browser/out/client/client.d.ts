/// <reference types="node" />
import * as buffer from "buffer";
import * as crypto from "crypto";
import * as events from "events";
import * as stream from "stream";
import * as timers from "timers";
import * as tty from "tty";
import * as path from "path";
import * as util from "util";
import * as sd from "string_decoder";
import { Logger, ReadWriteConnection } from "../common/connection";
import * as Message from "../common/messages";
import { Module } from "../common/proxy";
import { ChildProcessModule } from "./child_process";
import { FsModule } from "./fs";
import { NetModule } from "./net";
import { OsModule } from "./os";
export interface ClientOptions {
    readonly logger?: Logger;
}
/**
 * Client accepts a connection to communicate with the server.
 */
export declare class Client {
    private readonly connection;
    private readonly options?;
    private messageId;
    private callbackId;
    private clientId;
    private readonly proxies;
    private readonly successEmitter;
    private readonly failEmitter;
    private readonly eventEmitter;
    private readonly initDataEmitter;
    private status;
    private pingTimeout;
    private readonly pingTimeoutDelay;
    private readonly responseTimeout;
    readonly modules: {
        [Module.Buffer]: typeof buffer;
        [Module.ChildProcess]: ChildProcessModule;
        [Module.Crypto]: typeof crypto;
        [Module.Events]: typeof events;
        [Module.Fs]: FsModule;
        [Module.Net]: NetModule;
        [Module.Os]: OsModule;
        [Module.Path]: typeof path;
        [Module.Process]: typeof process;
        [Module.Stream]: typeof stream;
        [Module.StringDecoder]: typeof sd;
        [Module.Timers]: typeof timers;
        [Module.Tty]: typeof tty;
        [Module.Util]: typeof util;
    };
    private readonly logger;
    private readonly _handshake;
    /**
     * @param connection Established connection to the server
     */
    constructor(connection: ReadWriteConnection, options?: ClientOptions | undefined);
    /**
     * Get the handshake promise. This isn't necessary to start communicating but
     * is generally a good idea since some fills get their data from it.
     */
    handshake(): Promise<Message.Server.InitData>;
    /**
     * Make a remote call for a proxy's method.
     */
    private remoteCall;
    /**
     * Handle all messages from the server.
     */
    private handleMessage;
    /**
     * Convert success message to a success event.
     */
    private emitSuccess;
    /**
     * Convert fail message to a fail event.
     */
    private emitFail;
    /**
     * Emit an event received from the server. We could send requests for "on" to
     * the server and serialize functions using IDs, but doing it that way makes
     * it possible to miss events depending on whether the server receives the
     * request before it emits. Instead, emit all events from the server so all
     * events are always caught on the client.
     */
    private emitEvent;
    /**
     * Run a callback as requested by the server. Since we don't know when
     * callbacks get garbage collected we dispose them only when the proxy
     * disposes. That means they should only be used if they run for the lifetime
     * of the proxy (like child_process.exec), otherwise we'll leak. They should
     * also only be used when passed together with the method. If they are sent
     * afterward, they may never be called due to timing issues.
     */
    private runCallback;
    /**
     * Start the ping loop. Does nothing if already pinging.
     */
    private readonly startPinging;
    /**
     * Return a proxy that makes remote calls.
     */
    private createProxy;
    /**
     * We aren't guaranteed the promise will call all the `then` callbacks
     * synchronously once it resolves, so the event message can come in and fire
     * before a caller has been able to attach an event. Waiting for the promise
     * ensures it runs after everything else.
     */
    private ensureResolved;
    /**
     * Same as decode except provides createProxy.
     */
    private decode;
    /**
     * Get a proxy. Error if it doesn't exist.
     */
    private getProxy;
    private send;
}
