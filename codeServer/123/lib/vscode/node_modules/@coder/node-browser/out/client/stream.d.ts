/// <reference types="node" />
import * as stream from "stream";
import { ClientProxy, ClientServerProxy } from "../common/proxy";
import { DuplexProxy, ReadableProxy, WritableProxy } from "../server/stream";
export interface ClientWritableProxy extends WritableProxy, ClientServerProxy<stream.Writable> {
}
export declare class Writable<T extends ClientWritableProxy = ClientWritableProxy> extends ClientProxy<T> implements stream.Writable {
    readonly writable: boolean;
    readonly writableFinished: boolean;
    readonly writableHighWaterMark: number;
    readonly writableLength: number;
    _write(): void;
    _destroy(): void;
    _final(): void;
    pipe<T>(): T;
    cork(): void;
    uncork(): void;
    destroy(): void;
    setDefaultEncoding(encoding: string): this;
    write(chunk: any, encoding?: string | ((error?: Error | null) => void), callback?: (error?: Error | null) => void): boolean;
    end(data?: any | (() => void), encoding?: string | (() => void), callback?: () => void): void;
    protected handleDisconnect(): void;
}
export interface ClientReadableProxy extends ReadableProxy, ClientServerProxy<stream.Readable> {
}
export declare class Readable<T extends ClientReadableProxy = ClientReadableProxy> extends ClientProxy<T> implements stream.Readable {
    readonly readable: boolean;
    readonly readableHighWaterMark: number;
    readonly readableLength: number;
    _read(): void;
    read(): void;
    _destroy(): void;
    unpipe(): this;
    pause(): this;
    resume(): this;
    isPaused(): boolean;
    wrap(): this;
    push(): boolean;
    unshift(): void;
    pipe<P extends NodeJS.WritableStream>(destination: P, options?: {
        end?: boolean;
    }): P;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    destroy(): void;
    setEncoding(encoding: string): this;
    protected handleDisconnect(): void;
}
export interface ClientDuplexProxy extends DuplexProxy, ClientServerProxy<stream.Duplex> {
}
export declare class Duplex<T extends ClientDuplexProxy = ClientDuplexProxy> extends Writable<T> implements stream.Duplex, stream.Readable {
    private readonly _readable;
    constructor(proxyPromise: Promise<T> | T);
    readonly readable: boolean;
    readonly readableHighWaterMark: number;
    readonly readableLength: number;
    _read(): void;
    read(): void;
    unpipe(): this;
    pause(): this;
    resume(): this;
    isPaused(): boolean;
    wrap(): this;
    push(): boolean;
    unshift(): void;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    setEncoding(encoding: string): this;
    protected handleDisconnect(): void;
}
