(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require("./util");
    /* eslint-disable @typescript-eslint/no-explicit-any */
    var Type;
    (function (Type) {
        Type["Array"] = "array";
        Type["Buffer"] = "buffer";
        Type["Date"] = "date";
        Type["Error"] = "error";
        Type["Function"] = "function";
        Type["Object"] = "object";
        Type["Proxy"] = "proxy";
        Type["Undefined"] = "undefined";
    })(Type || (Type = {}));
    /**
     * Convert an argument for serialization.
     * If sending a function is possible, provide `storeFunction`.
     * If sending a proxy is possible, provide `storeProxy`.
     */
    exports.encode = function (value, storeFunction, storeProxy) {
        var convert = function (currentValue) {
            if (util_1.isNonModuleProxy(currentValue)) {
                if (!storeProxy) {
                    throw new Error("no way to serialize proxy");
                }
                var id = storeProxy(currentValue);
                if (typeof id === "string") {
                    throw new Error("unable to serialize module proxy");
                }
                return { type: Type.Proxy, id: id };
            }
            else if (currentValue instanceof Error ||
                (currentValue && typeof currentValue.message !== "undefined" && typeof currentValue.stack !== "undefined")) {
                return {
                    type: Type.Error,
                    code: currentValue.code,
                    message: currentValue.message,
                    stack: currentValue.stack,
                };
            }
            else if (currentValue instanceof Uint8Array || currentValue instanceof Buffer) {
                return { type: Type.Buffer, data: currentValue };
            }
            else if (Array.isArray(currentValue)) {
                return { type: Type.Array, values: currentValue.map(convert) };
            }
            else if (currentValue instanceof Date || (currentValue && typeof currentValue.getTime === "function")) {
                return { type: Type.Date, date: currentValue.toString() };
            }
            else if (currentValue !== null && typeof currentValue === "object") {
                var values_1 = {};
                Object.keys(currentValue).forEach(function (key) {
                    values_1[key] = convert(currentValue[key]);
                });
                return { type: Type.Object, values: values_1 };
            }
            else if (currentValue === null) {
                return currentValue;
            }
            switch (typeof currentValue) {
                case "undefined":
                    return { type: Type.Undefined };
                case "function":
                    if (!storeFunction) {
                        throw new Error("no way to serialize function");
                    }
                    return { type: Type.Function, id: storeFunction(currentValue) };
                case "number":
                case "string":
                case "boolean":
                    return currentValue;
            }
            throw new Error("cannot convert " + typeof currentValue + " to encoded argument");
        };
        return convert(value);
    };
    /**
     * Decode arguments into their original values.
     * If running a remote callback is supported, provide `runCallback`.
     * If using a remote proxy is supported, provide `createProxy`.
     */
    exports.decode = function (argument, runCallback, createProxy) {
        var convert = function (currentArgument) {
            switch (typeof currentArgument) {
                case "number":
                case "string":
                case "boolean":
                    return currentArgument;
            }
            if (currentArgument === null) {
                return currentArgument;
            }
            switch (currentArgument.type) {
                case Type.Array:
                    return currentArgument.values.map(convert);
                case Type.Buffer:
                    return Buffer.from(currentArgument.data);
                case Type.Date:
                    return new Date(currentArgument.date);
                case Type.Error: {
                    var error = new Error(currentArgument.message);
                    error.code = currentArgument.code;
                    error.originalStack = currentArgument.stack;
                    return error;
                }
                case Type.Function:
                    if (!runCallback) {
                        throw new Error("no way to run remote callback");
                    }
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return runCallback(currentArgument.id, args);
                    };
                case Type.Object: {
                    var obj_1 = {};
                    Object.keys(currentArgument.values).forEach(function (key) {
                        obj_1[key] = convert(currentArgument.values[key]);
                    });
                    return obj_1;
                }
                case Type.Proxy:
                    if (!createProxy) {
                        throw new Error("no way to create proxy");
                    }
                    return createProxy(currentArgument.id);
                case Type.Undefined:
                    return undefined;
            }
            throw new Error("cannot convert unexpected encoded argument to value");
        };
        return argument && convert(argument);
    };
});
