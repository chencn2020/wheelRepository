/// <reference types="node" />
import * as fs from "fs";
import { EncodingOptions, ServerProxy } from "../common/proxy";
import { ReadableProxy, WritableProxy } from "./stream";
/**
 * A serializable version of fs.Stats.
 */
export interface Stats {
    dev: number;
    ino: number;
    mode: number;
    nlink: number;
    uid: number;
    gid: number;
    rdev: number;
    size: number;
    blksize: number;
    blocks: number;
    atimeMs: number;
    mtimeMs: number;
    ctimeMs: number;
    birthtimeMs: number;
    atime: Date;
    mtime: Date;
    ctime: Date;
    birthtime: Date;
    _isFile: boolean;
    _isDirectory: boolean;
    _isBlockDevice: boolean;
    _isCharacterDevice: boolean;
    _isSymbolicLink: boolean;
    _isFIFO: boolean;
    _isSocket: boolean;
}
export declare class ReadStreamProxy extends ReadableProxy<fs.ReadStream> {
    constructor(stream: fs.ReadStream);
    close(): Promise<void>;
    dispose(): Promise<void>;
}
export declare class WriteStreamProxy extends WritableProxy<fs.WriteStream> {
    constructor(stream: fs.WriteStream);
    close(): Promise<void>;
    dispose(): Promise<void>;
}
export declare class WatcherProxy extends ServerProxy<fs.FSWatcher> {
    constructor(watcher: fs.FSWatcher);
    close(): Promise<void>;
    dispose(): Promise<void>;
}
export declare class FsModuleProxy {
    access(path: fs.PathLike, mode?: number): Promise<void>;
    appendFile(file: fs.PathLike | number, data: any, options?: fs.WriteFileOptions): Promise<void>;
    chmod(path: fs.PathLike, mode: string | number): Promise<void>;
    chown(path: fs.PathLike, uid: number, gid: number): Promise<void>;
    close(fd: number): Promise<void>;
    copyFile(src: fs.PathLike, dest: fs.PathLike, flags?: number): Promise<void>;
    createReadStream(path: fs.PathLike, options?: any): Promise<ReadStreamProxy>;
    createWriteStream(path: fs.PathLike, options?: any): Promise<WriteStreamProxy>;
    exists(path: fs.PathLike): Promise<boolean>;
    fchmod(fd: number, mode: string | number): Promise<void>;
    fchown(fd: number, uid: number, gid: number): Promise<void>;
    fdatasync(fd: number): Promise<void>;
    fstat(fd: number): Promise<Stats>;
    fsync(fd: number): Promise<void>;
    ftruncate(fd: number, len?: number | null): Promise<void>;
    futimes(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;
    lchmod(path: fs.PathLike, mode: string | number): Promise<void>;
    lchown(path: fs.PathLike, uid: number, gid: number): Promise<void>;
    link(existingPath: fs.PathLike, newPath: fs.PathLike): Promise<void>;
    lstat(path: fs.PathLike): Promise<Stats>;
    lstatBatch(args: {
        path: fs.PathLike;
    }[]): Promise<(Stats | Error)[]>;
    mkdir(path: fs.PathLike, mode: number | string | fs.MakeDirectoryOptions | undefined | null): Promise<void>;
    mkdtemp(prefix: string, options: EncodingOptions): Promise<string | Buffer>;
    open(path: fs.PathLike, flags: string | number, mode: string | number | undefined | null): Promise<number>;
    read(fd: number, length: number, position: number | null): Promise<{
        bytesRead: number;
        buffer: Buffer;
    }>;
    readFile(path: fs.PathLike | number, options: EncodingOptions): Promise<string | Buffer>;
    readdir(path: fs.PathLike, options: EncodingOptions): Promise<Buffer[] | fs.Dirent[] | string[]>;
    readdirBatch(args: {
        path: fs.PathLike;
        options: EncodingOptions;
    }[]): Promise<(Buffer[] | fs.Dirent[] | string[] | Error)[]>;
    readlink(path: fs.PathLike, options: EncodingOptions): Promise<string | Buffer>;
    realpath(path: fs.PathLike, options: EncodingOptions): Promise<string | Buffer>;
    rename(oldPath: fs.PathLike, newPath: fs.PathLike): Promise<void>;
    rmdir(path: fs.PathLike): Promise<void>;
    stat(path: fs.PathLike): Promise<Stats>;
    statBatch(args: {
        path: fs.PathLike;
    }[]): Promise<(Stats | Error)[]>;
    symlink(target: fs.PathLike, path: fs.PathLike, type?: fs.symlink.Type | null): Promise<void>;
    truncate(path: fs.PathLike, len?: number | null): Promise<void>;
    unlink(path: fs.PathLike): Promise<void>;
    utimes(path: fs.PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;
    write(fd: number, buffer: Buffer, offset?: number, length?: number, position?: number): Promise<{
        bytesWritten: number;
        buffer: Buffer;
    }>;
    writeFile(path: fs.PathLike | number, data: any, options: EncodingOptions): Promise<void>;
    watch(filename: fs.PathLike, options?: EncodingOptions): Promise<WatcherProxy>;
    private makeStatsSerializable;
}
