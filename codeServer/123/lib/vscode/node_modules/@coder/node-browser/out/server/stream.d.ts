/// <reference types="node" />
import { EventEmitter } from "events";
import * as stream from "stream";
import { ServerProxy } from "../common/proxy";
export declare class WritableProxy<T extends stream.Writable = stream.Writable> extends ServerProxy<T> {
    constructor(instance: T, bindEvents?: string[], delayedEvents?: string[]);
    destroy(): Promise<void>;
    end(data?: any, encoding?: string): Promise<void>;
    setDefaultEncoding(encoding: string): Promise<void>;
    write(data: any, encoding?: string): Promise<void>;
    dispose(): Promise<void>;
}
/**
 * This noise is because we can't do multiple extends and we also can't seem to
 * do `extends WritableProxy<T> implement ReadableProxy<T>` (for `DuplexProxy`).
 */
export interface CommonReadableProxy<T extends EventEmitter> extends ServerProxy<T> {
    pipe<P extends WritableProxy>(destination: P, options?: {
        end?: boolean;
    }): Promise<void>;
    setEncoding(encoding: string): Promise<void>;
}
export declare class ReadableProxy<T extends stream.Readable = stream.Readable> extends ServerProxy<T> implements CommonReadableProxy<T> {
    constructor(instance: T, bindEvents?: string[]);
    pipe<P extends WritableProxy>(destination: P, options?: {
        end?: boolean;
    }): Promise<void>;
    destroy(): Promise<void>;
    setEncoding(encoding: string): Promise<void>;
    dispose(): Promise<void>;
}
export declare class DuplexProxy<T extends stream.Duplex = stream.Duplex> extends WritableProxy<T> implements CommonReadableProxy<T> {
    constructor(stream: T, bindEvents?: string[]);
    pipe<P extends WritableProxy>(destination: P, options?: {
        end?: boolean;
    }): Promise<void>;
    setEncoding(encoding: string): Promise<void>;
    dispose(): Promise<void>;
}
