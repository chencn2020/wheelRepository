(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.requirefs = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
// NOTE: Taken from Node source and modified. Here's the license for that:
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
Object.defineProperty(exports, "__esModule", { value: true });
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
// Resolves . and .. elements in a path with directory names
function normalizeString(path, allowAboveRoot, separator) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code = 0;
    for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
            code = path.charCodeAt(i);
        else if (isPathSeparator(code))
            break;
        else
            code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {
                // NOOP
            }
            else if (dots === 2) {
                if (res.length < 2 ||
                    lastSegmentLength !== 2 ||
                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||
                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        }
                        else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                    else if (res.length !== 0) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    res += res.length > 0 ? separator + ".." : "..";
                    lastSegmentLength = 2;
                }
            }
            else {
                if (res.length > 0)
                    res += "" + separator + path.slice(lastSlash + 1, i);
                else
                    res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        }
        else if (code === CHAR_DOT && dots !== -1) {
            ++dots;
        }
        else {
            dots = -1;
        }
    }
    return res;
}
exports.normalize = function (path) {
    if (path.length === 0)
        return ".";
    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
    // Normalize the path
    path = normalizeString(path, !isAbsolute, "/");
    if (path.length === 0) {
        if (isAbsolute)
            return "/";
        return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator)
        path += "/";
    return isAbsolute ? "/" + path : path;
};
exports.join = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0)
        return ".";
    var joined;
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i];
        if (arg.length > 0) {
            if (joined === undefined)
                joined = arg;
            else
                joined += "/" + arg;
        }
    }
    if (joined === undefined)
        return ".";
    return exports.normalize(joined);
};
exports.dirname = function (path) {
    if (path.length === 0)
        return ".";
    var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        }
        else {
            // We saw the first non-path separator
            matchedSlash = false;
        }
    }
    if (end === -1)
        return hasRoot ? "/" : ".";
    if (hasRoot && end === 1)
        return "//";
    return path.slice(0, end);
};
exports.basename = function (path, ext) {
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext === path)
            return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else {
                if (firstNonSlashEnd === -1) {
                    // We saw the first non-path separator, remember this index in case
                    // we need it if the extension ends up not matching
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    // Try to match the explicit extension
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        }
                    }
                    else {
                        // Extension does not match, so our result is the entire path
                        // component
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end)
            end = firstNonSlashEnd;
        else if (end === -1)
            end = path.length;
        return path.slice(start, end);
    }
    for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
                start = i + 1;
                break;
            }
        }
        else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
        }
    }
    if (end === -1)
        return "";
    return path.slice(start, end);
};

},{}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Read bytes from a Uint8Array.
 */
var Reader = /** @class */ (function () {
    function Reader(array) {
        this.array = array;
        this._offset = 0;
        this.currentClamp = 0;
        this.textDecoder = new (typeof TextDecoder !== "undefined" ? TextDecoder : require("text-encoding").TextDecoder)();
    }
    Object.defineProperty(Reader.prototype, "offset", {
        get: function () {
            return this._offset;
        },
        enumerable: true,
        configurable: true
    });
    Reader.prototype.skip = function (amount) {
        this._offset += amount;
        return this;
    };
    Reader.prototype.clamp = function () {
        this.currentClamp = this._offset;
    };
    Reader.prototype.unclamp = function () {
        this.currentClamp = 0;
    };
    Reader.prototype.jump = function (offset) {
        this._offset = offset + this.currentClamp;
        return this;
    };
    Reader.prototype.eof = function () {
        return this.offset >= this.array.length;
    };
    Reader.prototype.peek = function (amount, encoding) {
        if (this.eof()) {
            throw new Error("EOF");
        }
        var data = this.array.slice(this.offset, this.offset + amount);
        // There may be nil bytes used as padding which we'll remove.
        return encoding ? this.textDecoder.decode(data.filter(function (byte) { return byte !== 0x00; })) : data;
    };
    Reader.prototype.read = function (amount, encoding) {
        var data = this.peek(amount, encoding); // eslint-disable-line @typescript-eslint/no-explicit-any
        this._offset += amount;
        return data;
    };
    return Reader;
}());
exports.Reader = Reader;

},{"text-encoding":undefined}],3:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("./path");
var resolver_1 = require("./resolver");
var tar_1 = require("./tar");
var originalExports = Symbol("originalExports");
/**
 * Allow requiring modules and files from a provided file system.
 */
var RequireFS = /** @class */ (function (_super) {
    __extends(RequireFS, _super);
    function RequireFS(reader) {
        var _this = _super.call(this) || this;
        _this.reader = reader;
        _this.customModules = new Map();
        _this.requireCache = new Map();
        return _this;
    }
    /**
     * Provide a custom module.
     */
    RequireFS.prototype.provide = function (moduleName, value) {
        if (this.customModules.has(moduleName)) {
            throw new Error("custom module has already been registered with this name");
        }
        this.customModules.set(moduleName, value);
    };
    /**
     * Require a path relative to the root.
     */
    RequireFS.prototype.require = function (target) {
        return this.doRequire("./" + path.normalize(target), "./");
    };
    /**
     * Attempt to require the provided path. If the path requires another path, it
     * will recursively follow the dependency tree and return any exported data.
     */
    RequireFS.prototype.doRequire = function (importPath, directoryPath) {
        var _a;
        var _this = this;
        if (this.customModules.has(importPath)) {
            return this.customModules.get(importPath);
        }
        var resolvedPath = this.resolvePath(importPath, directoryPath);
        if (this.requireCache.has(resolvedPath)) {
            return this.requireCache.get(resolvedPath).exports;
        }
        // Provide globals that can be referenced in the `eval`.
        var exports = {};
        var module = (_a = { exports: exports }, _a[originalExports] = exports, _a);
        // We must do this immediately in case of circular imports. This means that
        // a circular import can't catch reassigned values but it's better than
        // failing.
        this.requireCache.set(resolvedPath, { exports: exports });
        /* eslint-disable @typescript-eslint/no-unused-vars */
        // @ts-ignore
        var __dirname = path.dirname(resolvedPath);
        // Some modules will try to use `define` if it exists (lodash) and we only
        // want modules using our custom-provided `require` function.
        // @ts-ignore
        var define = undefined;
        // @ts-ignore
        var require = function (target) {
            var nativeModule = _this.tryNativeRequire(target);
            if (typeof nativeModule !== "undefined" && nativeModule !== null) {
                return nativeModule;
            }
            return _this.doRequire(target, path.dirname(resolvedPath));
        };
        /* eslint-enable @typescript-eslint/no-unused-vars */
        var content = this.readFile(resolvedPath, "utf8");
        if (/\.json$/.test(resolvedPath)) {
            exports = JSON.parse(content);
        }
        else {
            eval("'use strict'; " + content);
            // It's possible that `exports` or `module.exports` have been reassigned.
            // In that case use the reassigned version, giving preference to
            // `exports`.
            if (exports === module[originalExports] && // exports not reassigned
                module.exports !== module[originalExports] // module.exports reassigned
            ) {
                exports = module.exports;
            }
        }
        // Set it again in case it was reassigned.
        this.requireCache.set(resolvedPath, { exports: exports });
        return exports;
    };
    /**
     * Require a module using NodeJS's `module.require`. Note that script runners
     * (e.g. Jest, which uses `resolve.Sync` under the hood) may interfere.
     */
    RequireFS.prototype.tryNativeRequire = function (modulePath) {
        try {
            return require(modulePath);
        }
        catch (e) {
            // Don't throw here. The module may be retrievable in another way.
        }
    };
    RequireFS.prototype.isFile = function (filePath) {
        return this.reader.exists(filePath);
    };
    RequireFS.prototype.readFile = function (filePath, encoding) {
        return this.reader.read(filePath, encoding);
    };
    return RequireFS;
}(resolver_1.Resolver));
exports.RequireFS = RequireFS;
/**
 * Return a readable and requirable file system from a tar.
 */
exports.fromTar = function (content) {
    var tar = tar_1.Tar.fromUint8Array(content);
    return new RequireFS({
        exists: function (filePath) {
            return !!tar.getFile(filePath);
        },
        read: function (filePath, encoding) {
            var file = tar.getFile(filePath);
            if (!file) {
                throw new Error("\"" + filePath + "\" does not exist");
            }
            return encoding ? file.read(encoding) : file.read();
        },
    });
};
/**
 * Return a readable and requirable file system from a zip.
 */
exports.fromZip = function (content) {
    // @ts-ignore
    var zip = new (require("jszip"))(content);
    return new RequireFS({
        exists: function (filePath) {
            return !!zip.file(filePath);
        },
        read: function (filePath, encoding) {
            var file = zip.file(filePath);
            if (!file) {
                throw new Error("\"" + filePath + "\" does not exist");
            }
            return encoding ? zip.file(filePath).asText() : zip.file(filePath).asUint8Array();
        },
    });
};

},{"./path":1,"./resolver":4,"./tar":5,"jszip":undefined}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("./path");
var Resolver = /** @class */ (function () {
    function Resolver() {
        this._extensions = [];
        this.extensions = [".js"];
    }
    Object.defineProperty(Resolver.prototype, "extensions", {
        /**
         * The list of acceptable extensions for resolving module files.
         */
        set: function (extensions) {
            this._extensions = extensions.map(function (extension) {
                return /^\./.test(extension) ? extension : "." + extension;
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Normalize and resolve importPath from directoryPath.
     */
    Resolver.prototype.resolvePath = function (importPath, directoryPath) {
        var basePath = path.normalize(directoryPath);
        if (this.isRelativePath(importPath)) {
            var candidate = this.maybeResolvePath(importPath, basePath);
            if (candidate) {
                return candidate;
            }
        }
        else {
            var candidate = this.maybeResolveModule(importPath, basePath);
            if (candidate) {
                return candidate;
            }
        }
        throw new Error("Unable to resolve " + importPath + " from " + directoryPath);
    };
    Resolver.prototype.isRelativePath = function (importPath) {
        return /^\.\.?(\/|$)/.test(importPath);
    };
    Resolver.prototype.maybeResolvePath = function (importPath, basePath) {
        var filePath = path.join(basePath, importPath);
        return this.maybeResolveFile(filePath) || this.maybeResolveDirectory(filePath);
    };
    /**
     * Try the raw path and all the valid extensions.
     */
    Resolver.prototype.maybeResolveFile = function (filePath) {
        if (this.isFile(filePath)) {
            return filePath;
        }
        for (var i = 0; i < this._extensions.length; ++i) {
            var withExt = "" + filePath + this._extensions[i];
            if (this.isFile(withExt)) {
                return withExt;
            }
        }
        return undefined;
    };
    /**
     * Try resolving using `package.json` inside a directory. If there is no
     * `package.json` or no `module` nor `main` specified within it, load the
     * index file if there is one instead.
     */
    Resolver.prototype.maybeResolveDirectory = function (directoryPath) {
        var json = this.maybeGetPackageJson(directoryPath);
        var entry = (json && (json.main || json.module)) || "index";
        return this.maybeResolveFile(path.join(directoryPath, entry));
    };
    /**
     * Try resolving a module by traversing upwards and looking into the
     * `node_modules` it encounters along the way.
     */
    Resolver.prototype.maybeResolveModule = function (importPath, basePath) {
        var nodeModulePath = path.join(basePath, "node_modules");
        var candidate = this.maybeResolvePath(importPath, nodeModulePath);
        if (candidate) {
            return candidate;
        }
        var dirname = path.dirname(basePath);
        return dirname !== basePath ? this.maybeResolveModule(importPath, dirname) : undefined;
    };
    /**
     * Try getting a `package.json` from a directory.
     */
    Resolver.prototype.maybeGetPackageJson = function (directoryPath) {
        var jsonPath = path.join(directoryPath, "package.json");
        if (this.isFile(jsonPath)) {
            var body = this.readFile(jsonPath, "utf8");
            try {
                return JSON.parse(body);
            }
            catch (e) {
                // Ignore JSON errors.
            }
        }
        return undefined;
    };
    return Resolver;
}());
exports.Resolver = Resolver;

},{"./path":1}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("./path");
var reader_1 = require("./reader");
var Type;
(function (Type) {
    Type[Type["Dir"] = 0] = "Dir";
    Type[Type["File"] = 1] = "File";
})(Type || (Type = {}));
var TarFile = /** @class */ (function () {
    function TarFile(header, offset, reader) {
        this.header = header;
        this.offset = offset;
        this.reader = reader;
    }
    TarFile.prototype.read = function (encoding) {
        return this.reader.jump(this.offset).read(this.header.size, encoding); // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    return TarFile;
}());
exports.TarFile = TarFile;
var Tar = /** @class */ (function () {
    function Tar() {
        this.files = new Map();
    }
    Tar.prototype.getFile = function (filePath) {
        return this.files.get(filePath);
    };
    Tar.fromUint8Array = function (array) {
        var reader = new reader_1.Reader(array);
        var gzipBytes = reader.peek(2);
        if (gzipBytes[0] === 0x1f && gzipBytes[1] === 0x8b) {
            throw new Error("gzipped tars are not supported");
        }
        var tar = new Tar();
        var file;
        while ((file = Tar.getNextFile(reader))) {
            if (file.header.type === Type.File) {
                tar.files.set(path.normalize(file.header.name), file);
            }
        }
        reader.unclamp();
        return tar;
    };
    Tar.getNextFile = function (reader) {
        if (reader.eof()) {
            return undefined;
        }
        var header = Tar.parseHeader(reader);
        reader.jump(512);
        var offset = reader.offset;
        reader.skip(header.size);
        // Blocks are 512 in size and the remaining will be padding so we need to
        // skip past however much padding there is for the last block.
        var overflow = header.size & 511;
        if (overflow > 0) {
            reader.skip(512 - overflow);
        }
        // There can also be empty padding block(s) after a file.
        try {
            while (reader.peek(1)[0] === 0x00) {
                reader.skip(512);
            }
        }
        catch (error) {
            // EOF
        }
        reader.clamp();
        return new TarFile(header, offset, reader);
    };
    // See https://www.gnu.org/software/tar/manual/html_node/Standard.html
    Tar.parseHeader = function (reader) {
        // Tar uses base256 encoding for very large numbers. 0xff is a negative
        // number and 0x80 is a positive number.
        var sign = reader.jump(124).peek(1)[0];
        if (sign === 0xff || sign === 0x80) {
            throw new Error("base256 encoding not supported");
        }
        var prefix = reader.jump(345).read(155, "utf8");
        return {
            name: (prefix ? prefix + "/" : "") + reader.jump(0).read(100, "utf8"),
            size: parseInt(reader.jump(124).read(12, "utf8"), 8),
            type: reader.jump(156).read(1)[0] === 53 ? Type.Dir : Type.File,
        };
    };
    return Tar;
}());
exports.Tar = Tar;

},{"./path":1,"./reader":2}]},{},[3])(3)
});
