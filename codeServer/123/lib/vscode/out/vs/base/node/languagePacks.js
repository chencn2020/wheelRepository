/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";function factory(e,n,r,t){function o(e){return new Promise(n=>r.exists(e,n))}function i(e){return(t=e,new Promise((e,n)=>r.lstat(t,(r,t)=>r?n(r):e(t)))).then(t=>t.isDirectory()&&!t.isSymbolicLink()?function(e){return new Promise((n,t)=>r.readdir(e,(e,r)=>e?t(e):n(r)))}(e).then(r=>Promise.all(r.map(r=>i(n.join(e,r))))).then(()=>(function(e){return new Promise((n,t)=>r.rmdir(e,e=>e?t(e):n(void 0)))})(e)):function(e){return new Promise((n,t)=>r.unlink(e,e=>e?t(e):n(void 0)))}(e),e=>{if("ENOENT"!==e.code)throw e});var t}function s(e){return new Promise((function(n,t){r.readFile(e,"utf8",(function(e,r){e?t(e):n(r)}))}))}function a(e,n){return new Promise((function(t,o){r.writeFile(e,n,"utf8",(function(e){e?o(e):t()}))}))}return{getNLSConfiguration:function(e,c,u,l){if("pseudo"===l)return Promise.resolve({locale:l,availableLanguages:{},pseudo:!0});if(process.env.VSCODE_DEV)return Promise.resolve({locale:l,availableLanguages:{}});if(l&&("en"===l||"en-us"===l))return Promise.resolve({locale:l,
availableLanguages:{}});const f=l;t.mark("nlsGeneration:start");const m=function(e){return t.mark("nlsGeneration:end"),Promise.resolve({locale:e,availableLanguages:{}})};try{if(!e)return m(f);const d=function(e){const t=n.join(e,"languagepacks.json");try{return JSON.parse(r.readFileSync(t,"utf8"))}catch(e){}}(c);if(!d)return m(f);if(!(l=function(e,n){try{for(;n;){if(e[n])return n;{const e=n.lastIndexOf("-");if(!(e>0))return;n=n.substring(0,e)}}}catch(e){console.error("Resolving language pack configuration failed.",e)}}(d,l)))return m(f);const g=d[l];let h;return g&&"string"==typeof g.hash&&g.translations&&"string"==typeof(h=g.translations.vscode)?o(h).then(d=>{if(!d)return m(f);const p=g.hash+"."+l,v=n.join(c,"clp",p),y=n.join(v,e),P=n.join(v,"tcf.json"),k=n.join(v,"corrupted.info"),w={locale:f,availableLanguages:{"*":l},_languagePackId:p,_translationsConfigFile:P,_cacheRoot:v,_resolvedLanguagePackCoreLocation:y,_corruptedFile:k};return o(k).then(e=>{let c
;return(c=e?i(v):Promise.resolve(void 0)).then(()=>o(y).then(e=>e?(function(e){return new Promise((n,t)=>{const o=new Date;r.utimes(e,o,o,e=>e?t(e):n())})}(y).catch(()=>{}),t.mark("nlsGeneration:end"),w):function(e){return new Promise((n,t)=>r.mkdir(e,{recursive:!0},r=>r&&"EEXIST"!==r.code?t(r):n(e)))}(y).then(()=>Promise.all([s(u),s(h)])).then(e=>{const r=JSON.parse(e[0]),t=JSON.parse(e[1]).contents,o=Object.keys(r.bundles),i=[];for(const e of o){const o=r.bundles[e],s=Object.create(null);for(const e of o){const n=r.keys[e],o=r.messages[e],i=t[e];let a;if(i){a=[];for(let e=0;e<n.length;e++){const r=n[e];let t=i["string"==typeof r?r:r.key];void 0===t&&(t=o[e]),a.push(t)}}else a=o;s[e]=a}i.push(a(n.join(y,e.replace(/\//g,"!")+".nls.json"),JSON.stringify(s)))}return i.push(a(P,JSON.stringify(g.translations))),Promise.all(i)}).then(()=>(t.mark("nlsGeneration:end"),w)).catch(e=>(console.error("Generating translation files failed.",e),m(l)))))})}):m(f)}catch(e){
return console.error("Generating translation files failed.",e),m(l)}}}}if("function"==typeof define)define(["path","fs","vs/base/common/performance"],(function(e,n,r){return factory(require.__$__nodeRequire,e,n,r)}));else{if("object"!=typeof module||"object"!=typeof module.exports)throw new Error("Unknown context");{const e=require("path"),n=require("fs"),r=require("../common/performance");module.exports=factory(require,e,n,r)}}
//# sourceMappingURL=languagePacks.js.map
