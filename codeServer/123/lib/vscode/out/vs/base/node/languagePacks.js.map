{"version":3,"sources":["vs/base/node/languagePacks.js"],"names":["factory","nodeRequire","path","fs","perf","exists","file","Promise","c","rimraf","location","e","lstat","err","stats","then","stat","isDirectory","isSymbolicLink","dir","readdir","files","children","all","map","child","join","rmdir","undefined","unlink","code","readFile","resolve","reject","data","writeFile","content","getNLSConfiguration","commit","userDataPath","metaDataFile","locale","availableLanguages","pseudo","process","env","initialLocale","mark","defaultResult","configs","configFile","JSON","parse","readFileSync","getLanguagePackConfigurations","config","index","lastIndexOf","substring","console","error","resolveLanguagePackLocale","packConfig","mainPack","hash","translations","fileExists","packId","cacheRoot","coreLocation","translationsConfigFile","corruptedFile","result","*","_languagePackId","_translationsConfigFile","_cacheRoot","_resolvedLanguagePackCoreLocation","_corruptedFile","corrupted","toDelete","d","Date","utimes","touch","catch","mkdir","recursive","mkdirp","values","metadata","packData","contents","bundles","Object","keys","writes","bundle","modules","target","create","module","defaultMessages","messages","targetStrings","i","length","elem","translatedMessage","key","push","replace","stringify","define","require","__$__nodeRequire","exports","Error"],"mappings":"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","file":"languagePacks.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n//@ts-check\n\n/**\n * @param {NodeRequire} nodeRequire\n * @param {typeof import('path')} path\n * @param {typeof import('fs')} fs\n * @param {typeof import('../common/performance')} perf\n */\nfunction factory(nodeRequire, path, fs, perf) {\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<boolean>}\n\t */\n\tfunction exists(file) {\n\t\treturn new Promise(c => fs.exists(file, c));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction touch(file) {\n\t\treturn new Promise((c, e) => { const d = new Date(); fs.utimes(file, d, d, err => err ? e(err) : c()); });\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<object>}\n\t */\n\tfunction lstat(file) {\n\t\treturn new Promise((c, e) => fs.lstat(file, (err, stats) => err ? e(err) : c(stats)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string[]>}\n\t */\n\tfunction readdir(dir) {\n\t\treturn new Promise((c, e) => fs.readdir(dir, (err, files) => err ? e(err) : c(files)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string>}\n\t */\n\tfunction mkdirp(dir) {\n\t\treturn new Promise((c, e) => fs.mkdir(dir, { recursive: true }, err => (err && err.code !== 'EEXIST') ? e(err) : c(dir)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<void>}\n\t */\n\tfunction rmdir(dir) {\n\t\treturn new Promise((c, e) => fs.rmdir(dir, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction unlink(file) {\n\t\treturn new Promise((c, e) => fs.unlink(file, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} location\n\t * @returns {Promise<void>}\n\t */\n\tfunction rimraf(location) {\n\t\treturn lstat(location).then(stat => {\n\t\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\t\treturn readdir(location)\n\t\t\t\t\t.then(children => Promise.all(children.map(child => rimraf(path.join(location, child)))))\n\t\t\t\t\t.then(() => rmdir(location));\n\t\t\t} else {\n\t\t\t\treturn unlink(location);\n\t\t\t}\n\t\t}, err => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\tfunction readFile(file) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.readFile(file, 'utf8', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @param {string} content\n\t * @returns {Promise<void>}\n\t */\n\tfunction writeFile(file, content) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.writeFile(file, content, 'utf8', function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\n\t/**\n\t * @param {string} userDataPath\n\t * @returns {object}\n\t */\n\tfunction getLanguagePackConfigurations(userDataPath) {\n\t\tconst configFile = path.join(userDataPath, 'languagepacks.json');\n\t\ttry {\n\t\t\t// NOTE@coder: Swapped require with readFile since require is cached and\n\t\t\t// we don't restart the server-side portion of code-server when the\n\t\t\t// language changes.\n\t\t\treturn JSON.parse(fs.readFileSync(configFile, \"utf8\"));\n\t\t} catch (err) {\n\t\t\t// Do nothing. If we can't read the file we have no\n\t\t\t// language pack config.\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {object} config\n\t * @param {string} locale\n\t */\n\tfunction resolveLanguagePackLocale(config, locale) {\n\t\ttry {\n\t\t\twhile (locale) {\n\t\t\t\tif (config[locale]) {\n\t\t\t\t\treturn locale;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('Resolving language pack configuration failed.', err);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {string} commit\n\t * @param {string} userDataPath\n\t * @param {string} metaDataFile\n\t * @param {string} locale\n\t */\n\tfunction getNLSConfiguration(commit, userDataPath, metaDataFile, locale) {\n\t\tif (locale === 'pseudo') {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {}, pseudo: true });\n\t\t}\n\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\t// We have a built version so we have extracted nls file. Try to find\n\t\t// the right file to use.\n\n\t\t// Check if we have an English or English US locale. If so fall to default since that is our\n\t\t// English translation (we don't ship *.nls.en.json files)\n\t\tif (locale && (locale === 'en' || locale === 'en-us')) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\tconst initialLocale = locale;\n\n\t\tperf.mark('nlsGeneration:start');\n\n\t\tconst defaultResult = function (locale) {\n\t\t\tperf.mark('nlsGeneration:end');\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t};\n\t\ttry {\n\t\t\tif (!commit) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst configs = getLanguagePackConfigurations(userDataPath);\n\t\t\tif (!configs) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tlocale = resolveLanguagePackLocale(configs, locale);\n\t\t\tif (!locale) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst packConfig = configs[locale];\n\t\t\tlet mainPack;\n\t\t\tif (!packConfig || typeof packConfig.hash !== 'string' || !packConfig.translations || typeof (mainPack = packConfig.translations['vscode']) !== 'string') {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\treturn exists(mainPack).then(fileExists => {\n\t\t\t\tif (!fileExists) {\n\t\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t\t}\n\t\t\t\tconst packId = packConfig.hash + '.' + locale;\n\t\t\t\tconst cacheRoot = path.join(userDataPath, 'clp', packId);\n\t\t\t\tconst coreLocation = path.join(cacheRoot, commit);\n\t\t\t\tconst translationsConfigFile = path.join(cacheRoot, 'tcf.json');\n\t\t\t\tconst corruptedFile = path.join(cacheRoot, 'corrupted.info');\n\t\t\t\tconst result = {\n\t\t\t\t\tlocale: initialLocale,\n\t\t\t\t\tavailableLanguages: { '*': locale },\n\t\t\t\t\t_languagePackId: packId,\n\t\t\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t\t\t_cacheRoot: cacheRoot,\n\t\t\t\t\t_resolvedLanguagePackCoreLocation: coreLocation,\n\t\t\t\t\t_corruptedFile: corruptedFile\n\t\t\t\t};\n\t\t\t\treturn exists(corruptedFile).then(corrupted => {\n\t\t\t\t\t// The nls cache directory is corrupted.\n\t\t\t\t\tlet toDelete;\n\t\t\t\t\tif (corrupted) {\n\t\t\t\t\t\ttoDelete = rimraf(cacheRoot);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoDelete = Promise.resolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t\treturn toDelete.then(() => {\n\t\t\t\t\t\treturn exists(coreLocation).then(fileExists => {\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\t// We don't wait for this. No big harm if we can't touch\n\t\t\t\t\t\t\t\ttouch(coreLocation).catch(() => { });\n\t\t\t\t\t\t\t\tperf.mark('nlsGeneration:end');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mkdirp(coreLocation).then(() => {\n\t\t\t\t\t\t\t\treturn Promise.all([readFile(metaDataFile), readFile(mainPack)]);\n\t\t\t\t\t\t\t}).then(values => {\n\t\t\t\t\t\t\t\tconst metadata = JSON.parse(values[0]);\n\t\t\t\t\t\t\t\tconst packData = JSON.parse(values[1]).contents;\n\t\t\t\t\t\t\t\tconst bundles = Object.keys(metadata.bundles);\n\t\t\t\t\t\t\t\tconst writes = [];\n\t\t\t\t\t\t\t\tfor (const bundle of bundles) {\n\t\t\t\t\t\t\t\t\tconst modules = metadata.bundles[bundle];\n\t\t\t\t\t\t\t\t\tconst target = Object.create(null);\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst keys = metadata.keys[module];\n\t\t\t\t\t\t\t\t\t\tconst defaultMessages = metadata.messages[module];\n\t\t\t\t\t\t\t\t\t\tconst translations = packData[module];\n\t\t\t\t\t\t\t\t\t\tlet targetStrings;\n\t\t\t\t\t\t\t\t\t\tif (translations) {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst elem = keys[i];\n\t\t\t\t\t\t\t\t\t\t\t\tconst key = typeof elem === 'string' ? elem : elem.key;\n\t\t\t\t\t\t\t\t\t\t\t\tlet translatedMessage = translations[key];\n\t\t\t\t\t\t\t\t\t\t\t\tif (translatedMessage === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttranslatedMessage = defaultMessages[i];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\ttargetStrings.push(translatedMessage);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = defaultMessages;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttarget[module] = targetStrings;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twrites.push(writeFile(path.join(coreLocation, bundle.replace(/\\//g, '!') + '.nls.json'), JSON.stringify(target)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrites.push(writeFile(translationsConfigFile, JSON.stringify(packConfig.translations)));\n\t\t\t\t\t\t\t\treturn Promise.all(writes);\n\t\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t\tperf.mark('nlsGeneration:end');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}).catch(err => {\n\t\t\t\t\t\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\t\t\t\t\t\treturn defaultResult(locale);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\treturn defaultResult(locale);\n\t\t}\n\t}\n\n\treturn {\n\t\tgetNLSConfiguration\n\t};\n}\n\n\nif (typeof define === 'function') {\n\t// amd\n\tdefine(['path', 'fs', 'vs/base/common/performance'], function (path, fs, perf) { return factory(require.__$__nodeRequire, path, fs, perf); });\n} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\tconst path = require('path');\n\tconst fs = require('fs');\n\tconst perf = require('../common/performance');\n\tmodule.exports = factory(require, path, fs, perf);\n} else {\n\tthrow new Error('Unknown context');\n}\n"]}