{"version":3,"sources":["vs/workbench/contrib/webview/browser/pre/service-worker.js"],"names":["VERSION","rootPath","self","location","pathname","replace","resourceRoot","resolveTimeout","RequestStore","[object Object]","this","map","Map","webviewId","path","entry","get","_key","promise","existing","resolve","Promise","r","key","set","timeout","setTimeout","clearTimeout","delete","result","resourceRequestStore","localhostRequestStore","notFound","Response","status","async","processResourceRequest","event","requestUrl","client","clients","clientId","console","log","getWebviewIdForClient","resourcePath","startsWith","slice","length","resolveResourceEntry","body","headers","Content-Type","mime","parentClient","getOuterIframeClient","then","postMessage","channel","create","processLocalhostRequest","origin","resolveRedirect","redirectOrigin","fetch","request","url","RegExp","Location","URL","search","match","matchAll","includeUncontrolled","find","clientUrl","addEventListener","data","source","id","version","response","undefined","respondWith","host","waitUntil","skipWaiting","claim"],"mappings":"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","file":"service-worker.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst VERSION = 1;\n\nconst rootPath = self.location.pathname.replace(/\\/service-worker.js$/, '');\n\n/**\n * Root path for resources\n */\nconst resourceRoot = rootPath + '/vscode-resource';\n\nconst resolveTimeout = 30000;\n\n/**\n * @template T\n * @typedef {{\n *     resolve: (x: T) => void,\n *     promise: Promise<T>\n * }} RequestStoreEntry\n */\n\n/**\n * @template T\n */\nclass RequestStore {\n\tconstructor() {\n\t\t/** @type {Map<string, RequestStoreEntry<T>>} */\n\t\tthis.map = new Map();\n\t}\n\n\t/**\n\t * @param {string} webviewId\n\t * @param {string} path\n\t * @return {Promise<T> | undefined}\n\t */\n\tget(webviewId, path) {\n\t\tconst entry = this.map.get(this._key(webviewId, path));\n\t\treturn entry && entry.promise;\n\t}\n\n\t/**\n\t * @param {string} webviewId\n\t * @param {string} path\n\t * @returns {Promise<T>}\n\t */\n\tcreate(webviewId, path) {\n\t\tconst existing = this.get(webviewId, path);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\t\tlet resolve;\n\t\tconst promise = new Promise(r => resolve = r);\n\t\tconst entry = { resolve, promise };\n\t\tconst key = this._key(webviewId, path);\n\t\tthis.map.set(key, entry);\n\n\t\tconst dispose = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tconst existingEntry = this.map.get(key);\n\t\t\tif (existingEntry === entry) {\n\t\t\t\treturn this.map.delete(key);\n\t\t\t}\n\t\t};\n\t\tconst timeout = setTimeout(dispose, resolveTimeout);\n\t\treturn promise;\n\t}\n\n\t/**\n\t * @param {string} webviewId\n\t * @param {string} path\n\t * @param {T} result\n\t * @return {boolean}\n\t */\n\tresolve(webviewId, path, result) {\n\t\tconst entry = this.map.get(this._key(webviewId, path));\n\t\tif (!entry) {\n\t\t\treturn false;\n\t\t}\n\t\tentry.resolve(result);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} webviewId\n\t * @param {string} path\n\t * @return {string}\n\t */\n\t_key(webviewId, path) {\n\t\treturn `${webviewId}@@@${path}`;\n\t}\n}\n\n/**\n * Map of requested paths to responses.\n *\n * @type {RequestStore<{ body: any, mime: string } | undefined>}\n */\nconst resourceRequestStore = new RequestStore();\n\n/**\n * Map of requested localhost origins to optional redirects.\n *\n * @type {RequestStore<string | undefined>}\n */\nconst localhostRequestStore = new RequestStore();\n\nconst notFound = () =>\n\tnew Response('Not Found', { status: 404, });\n\nself.addEventListener('message', async (event) => {\n\tswitch (event.data.channel) {\n\t\tcase 'version':\n\t\t\t{\n\t\t\t\tself.clients.get(event.source.id).then(client => {\n\t\t\t\t\tif (client) {\n\t\t\t\t\t\tclient.postMessage({\n\t\t\t\t\t\t\tchannel: 'version',\n\t\t\t\t\t\t\tversion: VERSION\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\tcase 'did-load-resource':\n\t\t\t{\n\t\t\t\tconst webviewId = getWebviewIdForClient(event.source);\n\t\t\t\tconst data = event.data.data;\n\t\t\t\tconst response = data.status === 200\n\t\t\t\t\t? { body: data.data, mime: data.mime }\n\t\t\t\t\t: undefined;\n\n\t\t\t\tif (!resourceRequestStore.resolve(webviewId, data.path, response)) {\n\t\t\t\t\tconsole.log('Could not resolve unknown resource', data.path);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase 'did-load-localhost':\n\t\t\t{\n\t\t\t\tconst webviewId = getWebviewIdForClient(event.source);\n\t\t\t\tconst data = event.data.data;\n\t\t\t\tif (!localhostRequestStore.resolve(webviewId, data.origin, data.location)) {\n\t\t\t\t\tconsole.log('Could not resolve unknown localhost', data.origin);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\n\tconsole.log('Unknown message');\n});\n\nself.addEventListener('fetch', (event) => {\n\tconst requestUrl = new URL(event.request.url);\n\n\t// See if it's a resource request\n\tif (requestUrl.origin === self.origin && requestUrl.pathname.startsWith(resourceRoot + '/')) {\n\t\treturn event.respondWith(processResourceRequest(event, requestUrl));\n\t}\n\n\t// See if it's a localhost request\n\tif (requestUrl.origin !== self.origin && requestUrl.host.match(/^localhost:(\\d+)$/)) {\n\t\treturn event.respondWith(processLocalhostRequest(event, requestUrl));\n\t}\n});\n\nself.addEventListener('install', (event) => {\n\tevent.waitUntil(self.skipWaiting()); // Activate worker immediately\n});\n\nself.addEventListener('activate', (event) => {\n\tevent.waitUntil(self.clients.claim()); // Become available to all pages\n});\n\nasync function processResourceRequest(event, requestUrl) {\n\tconst client = await self.clients.get(event.clientId);\n\tif (!client) {\n\t\tconsole.log('Could not find inner client for request');\n\t\treturn notFound();\n\t}\n\n\tconst webviewId = getWebviewIdForClient(client);\n\tconst resourcePath = requestUrl.pathname.startsWith(resourceRoot + '/') ? requestUrl.pathname.slice(resourceRoot.length) :  requestUrl.pathname;\n\n\tfunction resolveResourceEntry(entry) {\n\t\tif (!entry) {\n\t\t\treturn notFound();\n\t\t}\n\t\treturn new Response(entry.body, {\n\t\t\tstatus: 200,\n\t\t\theaders: { 'Content-Type': entry.mime }\n\t\t});\n\t}\n\n\tconst parentClient = await getOuterIframeClient(webviewId);\n\tif (!parentClient) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\t// Check if we've already resolved this request\n\tconst existing = resourceRequestStore.get(webviewId, resourcePath);\n\tif (existing) {\n\t\treturn existing.then(resolveResourceEntry);\n\t}\n\n\tparentClient.postMessage({\n\t\tchannel: 'load-resource',\n\t\tpath: resourcePath\n\t});\n\n\treturn resourceRequestStore.create(webviewId, resourcePath)\n\t\t.then(resolveResourceEntry);\n}\n\n/**\n * @param {*} event\n * @param {URL} requestUrl\n */\nasync function processLocalhostRequest(event, requestUrl) {\n\tconst client = await self.clients.get(event.clientId);\n\tif (!client) {\n\t\t// This is expected when requesting resources on other localhost ports\n\t\t// that are not spawned by vs code\n\t\treturn undefined;\n\t}\n\tconst webviewId = getWebviewIdForClient(client);\n\tconst origin = requestUrl.origin;\n\n\tconst resolveRedirect = redirectOrigin => {\n\t\tif (!redirectOrigin) {\n\t\t\treturn fetch(event.request);\n\t\t}\n\t\tconst location = event.request.url.replace(new RegExp(`^${requestUrl.origin}(/|$)`), `${redirectOrigin}$1`);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: location\n\t\t\t}\n\t\t});\n\t};\n\n\tconst parentClient = await getOuterIframeClient(webviewId);\n\tif (!parentClient) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\t// Check if we've already resolved this request\n\tconst existing = localhostRequestStore.get(webviewId, origin);\n\tif (existing) {\n\t\treturn existing.then(resolveRedirect);\n\t}\n\n\tparentClient.postMessage({\n\t\tchannel: 'load-localhost',\n\t\torigin: origin\n\t});\n\n\treturn localhostRequestStore.create(webviewId, origin)\n\t\t.then(resolveRedirect);\n}\n\nfunction getWebviewIdForClient(client) {\n\tconst requesterClientUrl = new URL(client.url);\n\treturn requesterClientUrl.search.match(/\\bid=([a-z0-9-]+)/i)[1];\n}\n\nasync function getOuterIframeClient(webviewId) {\n\tconst allClients = await self.clients.matchAll({ includeUncontrolled: true });\n\treturn allClients.find(client => {\n\t\tconst clientUrl = new URL(client.url);\n\t\treturn (clientUrl.pathname === `${rootPath}/` || clientUrl.pathname === `${rootPath}/index.html`) && clientUrl.search.match(new RegExp('\\\\bid=' + webviewId));\n\t});\n}"]}